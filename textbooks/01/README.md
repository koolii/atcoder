# アルゴリズム的思考力が身につく プログラミングコンテスト AtCoder 入門

## Python

- 演算子「\*」(Extended Iterable Unpacking Operator)

## if 文を減らす

```cpp
result = min(result, counter);
```

```cpp
if (result > counter) {
  result = counter
}
```

一般にプログラム中の if 文が増えるとバグが生じやすい傾向にあります。
例えば if 文の条件式で不等号の向きを誤る可能性が考えられます。

if 文を減らす意識を持つことで、プログラムにバグを混入させる可能性を減らせます。

## ソート

競技プログラミングでは、ソートアルゴリズムを自前実装することはほとんどない

## スライス記法

文字列の部分文字列を取得する際に start,end を指定する記法を言う
start を省略した場合は、S の先頭の要素から取り出すことを表し、
end を省略した場合は、S の末尾の要素まで取り出すことを表す

```python
S = "AtCoder"

# 7
print(len(S))

# "AtCoderContest"
print(S + "Contest")

# "Cod"
print(S[2:5])

# "tCoder"
print(S[1:])

# "AtCod
print(S[:-2])
```

## 全探索

見た目がいかにも数学であるような問題がよく出題されるが、むしろ、力任せな探索法を考えたほうが良いことも多々ある
単純な全探索方だと TLE なることもあるが、高速化により AC にもなりえる

## 二次元配列

- 長方形状のデータ
- グラフ

## list 型の標準出力

list 型をそのまま出力すると list 型としての出力になる
アスタリスク "*" を用いることで、list の各要素を個別に取り出して print()関数に渡すことが可能
ただし、print(*row)と書くと、変数 row の各文字毎に空白文字が挿入されてしまう
print(\*row, sep="")と書くことで、空白文字もなくすことができる

```python
row = ["A", "t", "C", "o", "d", "e", "r"]
print(*row, sep="")
```

## 計算量

AtCoder では O(N^2)の計算量を持つ開放を O(N)や O(N log N)へと改善することを要求する問題が多く見られる

### 線形探索法

「0 異常 16 未満の整数値」を当てるために「Yes/No で答えられる質問」が可能

0 から順番に最悪 16 通りの質問を繰り返す方法を線形探索法

### 二分探索法

「8 以上ですか？」と聞き、`0 <= x < 8` か `8 <= x < 16` に絞り込む
次に Yes/No の結果からその半分の値で以上・以下を質問し、8 通りから 4 通りに絞り込むことができる
これを繰り返すと、必ず 4 回の質問で当たられることが分かる。

このように「探索範囲を半減させていく」という考え方を二分探索法と呼ばれるアルゴリズムに相当する

`N = 2^k` を表せられる場合、 `k = (log N)` 回の計算量となる
二分探索法は `16 = 2^4` となるため、logN 回の計算量であることが分かる

これらのことから二分探索法の方が効率が良いことが分かる

### 総和

1 から N までの総和は等差数列の和の公式から計算でき、O(1)となる

```python
N = int(input())
print(N * (N + 1) // 2)
```

### 最近点対問題

二次元座標平面上に N 個の点が与えられた時、最近点対（最も近い頂点のペア）の距離を計算する

4_5_ex3_closest_pair.py に O(N^2)実装がある(非効率)

※ Python3 では、ペアの全探索を行う時は、 `itertools.combinations` を用いるのが便利

## 全探索で計算量を減らす

5-2 の ABC85C 問題での教訓

問題では、a + b + c = N が成立する時、正直に実装すると、a,b,c の 3 重ループになる
ただ、これだと計算量が O(N^3)となり、TLE になってしまう

大事なことは、 **「動かしたい変数が複数あるときは、1 つだけ動かして考える」** という考え方が有効になる

### 3 つの変数を動かすのではなく、2 つを動かす

**変数を 3 つ同時に動かすのではなく、1 つか 2 つのみ動かして考える**

今回は、3 つの変数 a,b,c の内 a,b のみを動かしてみる
a + b + c = N という制約のため、 c = N - a - b が計算で算出することができる
これを使うと、 for c in range(N + 1)のループを消せる
最終的に O(N^3) => O(N^2) になる

## 5-3 バケット

配列の応用的な使い方の一つ
`A = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9]` というサイズ 13 の配列があったとする
これを夫々の数値の分布(配列 A の中の値の個数)を新しい配列で表してみると、
`B = [0, 2, 1, 2, 1, 3, 1, 0, 1, 2]` のようになる

このように、定義される新たな配列をバケットと呼ぶことがある

バケットは強力なデータ構造だが、バケットの添字は正の整数値のみに限られるデメリットがある

## 5-3 集合型 set

集合を管理できる set 型が標準で容易されている。
Python3 ではサイズの取得や、要素の挿入・削除・検索の計算量は全て（平均的に）O(1)となる

```python
# N個の入力データを集合Sに挿入していく
S = set(input() for i in range(N))
print(len(S))
```

## 5-3 連想配列

バケットよりも柔軟なデータ構造を利用する場合に使う

Python3 での連想配列としては、一般的に dict 型がよく用いられる。
だが、競技プログラミングでは存在しないキーに対する値も定義されていたほうが好都合であることが多いため
collections.defaultdict 型を用いると便利

cf. `5_3_ex1_collections_defaultdict.py`

### nC2 組み合わせ

AtCoder の問題を説いていく時、「N 個のものから 2 個選ぶ場合の数」を求める場面には良く出会う

なので `n * (n - 1) / 2` の数式は覚えても良いかもしれない

### 条件をわかりやすく言い換える

「Si は Sj のアナグラムである」という条件を「Si と Sj をそれぞれソートして一致する」と言い換えることができる

このように AtCoder の問題を解く上で、「分かりづらい条件をわかりやすく言い換えること」がポイントとなることが多々ある

「この条件をうまく言い換えられないだろうかと意識すること」が重要です

問題を沢山説いていくと、少しずつ「言い換えの勘所」がつかめるようになってくる（要するに慣れ？）

## 5-4 区間分割の一つ、連長圧縮（ランレングス圧縮）

※ 意外と良く出題される、実装は少々複雑となる

連長圧縮は、ある連続したデータを、そのデータ 1 つ分と連続した長さとの組で表現すること
例えば、"AAABBBBBAACDD" といった文字列を ("A", 3), ("B", 5), ("C", 1), ("D", 2) の様に圧縮することを言う

`5_4_ex1_compress.py`

## 5-5 グラフ

- 頂点・辺
- 無向グラフ・有向グラフ
- 二次元配列でグラフを表現する

### クエリ

クエリとは、データ構造（グラフもデータ構造の一種です）に値を挿入したり、変更したり、取り出したりする要求のことです。

## 5-6 累積和

サイズ N の配列 A に対して、次のように定義されるサイズ N+1 の配列 S のことを言う
S[v]は「配列 A の先頭から v 個分の総和」を表す(e.g. S[3]は A[0]、A[1]、A[2]の総和)

注意点として累積和の先頭の要素は **0** となる
S[0]では「何も足さない」事を意味するので 0 になるのは当然と考えることができる

S[0] = 0
S[1] = A[0]
S[2] = A[0] + A[1]
S[3] = A[0] + A[1] + A[2]
S[N] = A[0] + A[1] + A[2] + ... + A[N-1]

配列 A: [3,1,4,1,5] => 累積和 S: [0,3,4,8,9,14]

```python
# サイズNの配列Aが与えられているとする
# 最初が0の為、累積和のサイズはN+1となる
S = [0] * (N+1)
for i in range(N):
  S[i + 1] = S[i] + A[i]
```

### 区間クエリ

**整数 l,r が与えられた時、配列 A の区間 [l, r) の総和を求めよ**

配列 A の区間 [l, r) とは、A[l]、A[l+1] ... A[r-1]のことを指す
Python で言うところの A[l:r] と表すこともできます
※ A[r]は含まないことに注意

この問題は累積和を用いると O(1)で計算できる。単純な for-loop だと最悪 O(N)の計算量となる

S[l] = A[0] + A[1] + ... + A[l-1]
S[r] = A[0] + A[1] + ... + A[l-1] + A[l] + ... + A[r-1]
A[l] + ... A[r-1] = S[r] - A[l]

累積和自体の計算量が O(N)になってしまうが、その後累積和を繰り返し利用することが可能で、
区間クエリが大量に与えられた時等での計算量に大きく寄与する
