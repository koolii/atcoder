# アルゴリズム的思考力が身につく プログラミングコンテスト AtCoder 入門

## if 文を減らす

```cpp
result = min(result, counter);
```

```cpp
if (result > counter) {
  result = counter
}
```

一般にプログラム中の if 文が増えるとバグが生じやすい傾向にあります。
例えば if 文の条件式で不等号の向きを誤る可能性が考えられます。

if 文を減らす意識を持つことで、プログラムにバグを混入させる可能性を減らせます。

## ソート

競技プログラミングでは、ソートアルゴリズムを自前実装することはほとんどない

## スライス記法

文字列の部分文字列を取得する際に start,end を指定する記法を言う
start を省略した場合は、S の先頭の要素から取り出すことを表し、
end を省略した場合は、S の末尾の要素まで取り出すことを表す

```python
S = "AtCoder"

# 7
print(len(S))

# "AtCoderContest"
print(S + "Contest")

# "Cod"
print(S[2:5])

# "tCoder"
print(S[1:])

# "AtCod
print(S[:-2])
```

## 全探索

見た目がいかにも数学であるような問題がよく出題されるが、むしろ、力任せな探索法を考えたほうが良いことも多々ある
単純な全探索方だと TLE なることもあるが、高速化により AC にもなりえる

## 二次元配列

- 長方形状のデータ
- グラフ

## list 型の標準出力

list 型をそのまま出力すると list 型としての出力になる
アスタリスク "*" を用いることで、list の各要素を個別に取り出して print()関数に渡すことが可能
ただし、print(*row)と書くと、変数 row の各文字毎に空白文字が挿入されてしまう
print(\*row, sep="")と書くことで、空白文字もなくすことができる

```python
row = ["A", "t", "C", "o", "d", "e", "r"]
print(*row, sep="")
```

## 計算量

AtCoder では O(N^2)の計算量を持つ開放を O(N)や O(N log N)へと改善することを要求する問題が多く見られる

### 線形探索法

「0 異常 16 未満の整数値」を当てるために「Yes/No で答えられる質問」が可能

0 から順番に最悪 16 通りの質問を繰り返す方法を線形探索法

### 二分探索法

「8 以上ですか？」と聞き、`0 <= x < 8` か `8 <= x < 16` に絞り込む
次に Yes/No の結果からその半分の値で以上・以下を質問し、8 通りから 4 通りに絞り込むことができる
これを繰り返すと、必ず 4 回の質問で当たられることが分かる。

このように「探索範囲を半減させていく」という考え方を二分探索法と呼ばれるアルゴリズムに相当する

`N = 2^k` を表せられる場合、 `k = (log N)` 回の計算量となる
二分探索法は `16 = 2^4` となるため、logN 回の計算量であることが分かる

これらのことから二分探索法の方が効率が良いことが分かる

### 総和

1 から N までの総和は等差数列の和の公式から計算でき、O(1)となる

```python
N = int(input())
print(N * (N + 1) // 2)
```

### 最近点対問題

二次元座標平面上に N 個の点が与えられた時、最近点対（最も近い頂点のペア）の距離を計算する

4_5_ex3_closest_pair.py に O(N^2)実装がある(非効率)

※ Python3 では、ペアの全探索を行う時は、 `itertools.combinations` を用いるのが便利

## 全探索で計算量を減らす

5-2 の ABC85C 問題での教訓

問題では、a + b + c = N が成立する時、正直に実装すると、a,b,c の 3 重ループになる
ただ、これだと計算量が O(N^3)となり、TLE になってしまう

大事なことは、 **「動かしたい変数が複数あるときは、1 つだけ動かして考える」** という考え方が有効になる

### 3 つの変数を動かすのではなく、2 つを動かす

**変数を 3 つ同時に動かすのではなく、1 つか 2 つのみ動かして考える**

今回は、3 つの変数 a,b,c の内 a,b のみを動かしてみる
a + b + c = N という制約のため、 c = N - a - b が計算で算出することができる
これを使うと、 for c in range(N + 1)のループを消せる
最終的に O(N^3) => O(N^2) になる

## 5-3 バケット

配列の応用的な使い方の一つ
`A = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9]` というサイズ 13 の配列があったとする
これを夫々の数値の分布(配列 A の中の値の個数)を新しい配列で表してみると、
`B = [0, 2, 1, 2, 1, 3, 1, 0, 1, 2]` のようになる

このように、定義される新たな配列をバケットと呼ぶことがある

バケットは強力なデータ構造だが、バケットの添字は正の整数値のみに限られるデメリットがある

## 5-3 集合型 set

集合を管理できる set 型が標準で容易されている。
Python3 ではサイズの取得や、要素の挿入・削除・検索の計算量は全て（平均的に）O(1)となる

```python
# N個の入力データを集合Sに挿入していく
S = set(input() for i in range(N))
print(len(S))
```

## 5-3 連想配列

バケットよりも柔軟なデータ構造を利用する場合に使う

Python3 での連想配列としては、一般的に dict 型がよく用いられる。
だが、競技プログラミングでは存在しないキーに対する値も定義されていたほうが好都合であることが多いため
collections.defaultdict 型を用いると便利

cf. `5_3_ex1_collections_defaultdict.py`
