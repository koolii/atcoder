# ナップサック問題
# N 個の品物があります。i 番目の品物の重さは Wi で価値は Vi です。
# これらの品物からいくつか選んでナップサックに詰めていきます。
# ナップサックに入れる品物の重さの総和は W を超えてはいけません。
# 選んだ品物の価値の総和として考えられる最大値を求めてください。
# ただし、W, Wi, Vi は正の整数であるとします。

# 各品物に対して、「選ぶ」「選ばない」の 2 通りの選択肢があります
# これを 0,1 を使って「0 と 1 のみからなる長さ N の数列」と同一視できます。

N, W = map(int, input().split())
w = list(map(int, input().split()))
v = list(map(int, input().split()))

# 自分で理解したアルゴリズムの内容(今回の問題に対してもアルゴリズムの理解に苦しむ)
# rec()関数の再帰呼び出しをループを進めるということで考えた
#  数列Aの次の要素を "0" とする場合の、 score = rec(n + 1, sw, sv) は
# どの階層のレベルでも「選ばない」という選択肢は取ることが可能な為、if文等を使わずそのまま記載することができる
# 数列Aの次の要素を "1" とする場合の、score = rec(n + 1, sw + w[n], sv + v[n])だが、
# 「選ぶ」という選択肢を取るためには、元々条件があり、sw(品物の重さの総和)が W を超えてはいけないという制約があるため、
# 「選ぶ」ことができるかどうかを判定している
# すでに W を超えている場合は、更に深く(次の品物の考慮する)ループを進める必要がないためrec()関数を抜けている

# 直接数列Aを管理することはせず、代わりに以下の変数を管理しています
# - n: 「0と1からなる数列A」の長さ
# - sw: 現在の数列Aに対応する品物の重さの総和
# - sv: 現在の数列Aに対応する品物の価値の総和
def rec(n, sw, sv):
  if n == N:
    return sv

  # 価値の最大値を表す変数
  result = 0

  # 数列Aの次の要素を "0" とする場合
  # 新たな品物を「選ばない」場合に対応する
  score = rec(n + 1, sw, sv)
  result = max(result, score)

  # 数列Aの次の要素を "1" とする場合
  # 新たな品物を「選ぶ」場合に対応する
  # 重さは w[n] 増加し、価値は v[n] 増加する
  if sw + w[n] <= W:
    score = rec(n + 1, sw + w[n], sv + v[n])
    result = max(result, score)

  # 最大値を返す
  return result

print(rec(0, 0, 0))